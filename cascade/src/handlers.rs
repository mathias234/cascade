use crate::manager::StreamManager;
use crate::models::{HealthResponse, StatusResponse, StreamStatus};
use axum::{
    body::Body,
    extract::{Path, Query, Request},
    http::{header, StatusCode},
    response::{IntoResponse, Json, Response},
};
use chrono::Utc;
use serde::Deserialize;
use std::sync::Arc;
use tracing::{debug, error, info};

#[derive(Debug, Deserialize)]
pub struct ContextQuery {
    hls_ctx: Option<String>,
}

/// Main HLS content handler that routes based on path pattern
pub async fn serve_hls_content(
    Path(path): Path<String>,
    Query(query): Query<ContextQuery>,
    _req: Request,
    manager: Arc<StreamManager>,
) -> impl IntoResponse {
    debug!("HLS request for path: {} with context: {:?}", path, query.hls_ctx);

    // Parse the path to determine what's being requested
    if path.ends_with(".m3u8") {
        // It's a playlist request - could be "stream_key/index.m3u8"
        let parts: Vec<&str> = path.split('/').collect();
        if parts.len() == 2 && parts[1] == "index.m3u8" {
            let stream_key = parts[0];

            // Check if we have a context parameter
            if query.hls_ctx.is_none() {
                // No context - serve master playlist with redirect
                serve_master_playlist(stream_key, manager).await
            } else {
                // Has context - serve actual playlist and track session
                serve_actual_playlist(stream_key, query.hls_ctx, manager).await
            }
        } else {
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(Body::from("Invalid playlist path"))
                .unwrap()
        }
    } else if path.ends_with(".ts") {
        // Segment file: "stream_key/segment.ts"
        let parts: Vec<&str> = path.split('/').collect();
        if parts.len() == 2 {
            let stream_key = parts[0];
            let segment = parts[1];
            serve_segment(stream_key, segment, manager).await
        } else {
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(Body::from("Invalid segment path"))
                .unwrap()
        }
    } else {
        Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .body(Body::from("Invalid file type"))
            .unwrap()
    }
}

/// Serve master playlist that redirects to actual playlist with context
async fn serve_master_playlist(
    stream_key: &str,
    manager: Arc<StreamManager>,
) -> Response<Body> {
    debug!("Master playlist request for stream: {} (no context)", stream_key);

    // Ensure stream is started
    if !manager.wait_for_stream(stream_key.to_string()).await {
        return Response::builder()
            .status(StatusCode::SERVICE_UNAVAILABLE)
            .header("Retry-After", "5")
            .body(Body::from("Stream not available"))
            .unwrap();
    }

    // Update stats
    {
        let mut stats = manager.stats.write().await;
        stats.requests += 1;
    }

    // Generate a new session for this viewer
    let session_id = manager.session_manager.create_session(stream_key);

    // Generate master playlist with redirect to the SAME path but with context
    let master_playlist = format!(
        "#EXTM3U\n#EXT-X-STREAM-INF:BANDWIDTH=1,AVERAGE-BANDWIDTH=1\n/live/{}/index.m3u8?hls_ctx={}",
        stream_key, session_id
    );

    Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, "application/vnd.apple.mpegurl")
        .header(header::CACHE_CONTROL, "no-cache")
        .body(Body::from(master_playlist))
        .unwrap()
}

/// Serve actual playlist with context tracking
async fn serve_actual_playlist(
    stream_key: &str,
    session_id: Option<String>,
    manager: Arc<StreamManager>,
) -> Response<Body> {
    debug!("Actual playlist request for stream: {} with session: {:?}", stream_key, session_id);

    // Update session if context provided
    if let Some(sid) = &session_id {
        manager.session_manager.update_session(sid);
    }

    // Update stats and stream access
    {
        let mut stats = manager.stats.write().await;
        stats.requests += 1;
    }
    manager.update_stream_access(stream_key).await;

    // Read the actual playlist file generated by FFmpeg
    let playlist_path = manager.hls_path.join(stream_key).join("index.m3u8");

    match tokio::fs::read(&playlist_path).await {
        Ok(data) => {
            // Convert the playlist content to string to modify segment URLs
            let content = String::from_utf8_lossy(&data);

            // Add the stream_key prefix to segment URLs in the playlist
            let modified_content = content
                .lines()
                .map(|line| {
                    if line.ends_with(".ts") {
                        // This is a segment filename, prepend the path
                        format!("/live/{}/{}", stream_key, line)
                    } else {
                        line.to_string()
                    }
                })
                .collect::<Vec<_>>()
                .join("\n");

            debug!("Serving playlist for stream {} ({} bytes)", stream_key, modified_content.len());
            Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_TYPE, "application/vnd.apple.mpegurl")
                .header(header::CACHE_CONTROL, "no-cache")
                .body(Body::from(modified_content))
                .unwrap()
        }
        Err(e) => {
            error!("Failed to read playlist file {:?}: {}", playlist_path, e);
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(Body::from("Playlist not found"))
                .unwrap()
        }
    }
}

/// Serve segment files
async fn serve_segment(
    stream_key: &str,
    segment: &str,
    manager: Arc<StreamManager>,
) -> Response<Body> {
    debug!("Segment request for stream: {}, segment: {}", stream_key, segment);

    // Update stats
    {
        let mut stats = manager.stats.write().await;
        stats.requests += 1;
    }
    manager.update_stream_access(stream_key).await;

    // Build the segment file path
    let segment_path = manager.hls_path.join(stream_key).join(segment);

    // Use cache for segments
    let cache_key = format!("{}/{}", stream_key, segment);
    match manager.cache.get_or_load(&cache_key, &segment_path).await {
        Ok(Some((cached_segment, was_cached))) => {
            let data_size = cached_segment.data.len();
            if was_cached {
                debug!("Serving from CACHE: {} ({} bytes)", segment, data_size);
            } else {
                info!("Serving NEWLY LOADED: {} ({} bytes)", segment, data_size);
            }
            Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_TYPE, cached_segment.content_type)
                .header(header::CACHE_CONTROL, "max-age=10")
                .body(Body::from(cached_segment.data.to_bytes()))
                .unwrap()
        }
        Ok(None) => {
            error!("Segment not found: {} at path {:?}", segment, segment_path);
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(Body::from("Segment not found"))
                .unwrap()
        }
        Err(e) => {
            error!("Error serving segment {}: {}", segment, e);
            Response::builder()
                .status(StatusCode::INTERNAL_SERVER_ERROR)
                .body(Body::from("Internal server error"))
                .unwrap()
        }
    }
}

pub async fn health_check(manager: Arc<StreamManager>) -> impl IntoResponse {
    let active_count = manager.active_streams.read().await.len();
    let pending_count = manager.pending_streams.read().await.len();
    let mut stats = manager.stats.read().await.clone();

    // Update total viewer count using sessions
    stats.total_viewers = manager.session_manager.get_total_viewer_count();

    let healthy = active_count < manager.max_concurrent_streams;

    let response = HealthResponse {
        status: if healthy { "healthy".to_string() } else { "unhealthy".to_string() },
        active_streams: active_count,
        pending_streams: pending_count,
        max_streams: manager.max_concurrent_streams,
        stats,
    };

    if healthy {
        (StatusCode::OK, Json(response))
    } else {
        (StatusCode::SERVICE_UNAVAILABLE, Json(response))
    }
}

pub async fn status(manager: Arc<StreamManager>) -> impl IntoResponse {
    let active = manager.active_streams.read().await;
    let now = Utc::now();

    let mut active_streams = Vec::new();
    for (key, info) in active.iter() {
        let last_accessed = info.last_accessed.read().await;

        active_streams.push(StreamStatus {
            key: key.clone(),
            pid: info.pid,
            uptime: now.signed_duration_since(info.started_at).num_seconds(),
            last_accessed: now.signed_duration_since(*last_accessed).num_seconds(),
            viewers: manager.session_manager.get_stream_viewer_count(key),
        });
    }

    let pending_streams: Vec<String> = manager.pending_streams.read().await
        .keys().cloned().collect();

    let failed_streams: Vec<String> = manager.failed_streams.read().await
        .keys().cloned().collect();

    let mut stats = manager.stats.read().await.clone();
    stats.total_viewers = manager.session_manager.get_total_viewer_count();

    Json(StatusResponse {
        active_streams,
        pending_streams,
        failed_streams,
        stats,
    })
}